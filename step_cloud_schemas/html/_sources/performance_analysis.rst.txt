Performance Space Analysis Methodology
======================================

The methodology for performance space analysis of algorithms is **Big O notation**.

**Big O notation** is a powerful tool used in computer science to describe the 
time complexity or space complexity of algorithms. Big-O is a way to express 
the upper bound of an algorithm's time or space complexity.

Key Points:
    #. Describes the asymptotic behavior (order of growth of time or space in terms 
       of input size) of a function, not its exact value.
    #. Can be used to compare the efficiency of different algorithms or data structures.
    #. It provides an upper limit on the time taken by an algorithm in terms of 
       the size of the input. We mainly consider the worst case scenario of the algorithm 
       to find its time complexity in terms of Big O.
    #. It's denoted as :math:`O(f(n))`, where :math:`f(n)` is a function that represents the number of 
       operations (steps) that an algorithm performs to solve a problem of size :math:`n`.

Big O Definition
----------------

Given two functions :math:`f(n)` and :math:`g(n)`, we say that :math:`f(n)` is :math:`O(g(n))` if there exist 
constants :math:`c > 0` and :math:`n_0 >= 0` such that :math:`f(n) <= c*g(n)` for all :math:`n >= n_0`. In simpler terms, 
:math:`f(n)` is :math:`O(g(n))` if :math:`f(n)` grows no faster than :math:`c*g(n)` for all :math:`n >= n_0`
where :math:`c` and :math:`n_0` are constants.

Importance of Big O Notation
----------------------------

**Big O notation** is a mathematical notation used to find an upper bound on time taken by an algorithm or data structure.
It provides a way to compare the performance of different algorithms and data structures, and to predict how they
will behave as the input size increases.

Big O notation is important for several reasons:

   * Big O Notation is important because it helps analyze the efficiency of algorithms.
   * It provides a way to describe how the runtime or space requirements of an algorithm grow as the input size increases.
   * Allows programmers to compare different algorithms and choose the most efficient one for a specific problem.
   * Helps in understanding the scalability of algorithms and predicting how they will perform as the input size grows.
   * Enables developers to optimize code and improve overall performance.
   * A Quick Way to find Big O of an Expression
   * Ignore the lower order terms and consider only highest order term.
   * Ignore the constant associated with the highest order term.

Properties of Big O Notation
----------------------------

Reflexivity
^^^^^^^^^^^

For any function :math:`f(n)`, :math:`f(n) = O(f(n))`.

**Example:**
  
.. math::

   f(n) = n^2 \Rightarrow f(n) = O(f(n))

Transitivity
^^^^^^^^^^^^

If :math:`f(n) = O(g(n))` and :math:`g(n) = O(h(n))`, then :math:`f(n) = O(h(n))`.

**Example:**

.. math::
   f(n) = n^2, g(n) = n^3, h(n) = n^4 \Rightarrow
   f(n) = O(g(n)) \text{ and } g(n) = O(h(n)) \Rightarrow
   f(n) = O(h(n))

Constant Factor
^^^^^^^^^^^^^^^

For any constant :math:`c > 0` and functions :math:`f(n)` and :math:`g(n)`, if :math:`f(n) = O(g(n))`, then :math:`cf(n) = O(g(n))`.

**Example:**

.. math::
   f(n) = n, g(n) = n^2 \Rightarrow f(n) = O(g(n)) \Rightarrow 2f(n) = O(g(n)).

Sum Rule
^^^^^^^^

If :math:`f(n) = O(g(n))` and :math:`h(n) = O(k(n))`, then :math:`f(n) + h(n) = O(\max( g(n), k(n) ))`. 
When combining complexities, only the largest term dominates.

**Example:**

.. math::
   f(n) = n^2, h(n) = n^3 \Rightarrow f(n) + h(n) = O(\max( n^2 + n^3 )) = O(n^3)

Product Rule
^^^^^^^^^^^^

If :math:`f(n) = O(g(n))` and :math:`h(n) = O(k(n))`, then :math:`f(n) * h(n) = O(g(n) * k(n))`.

**Example:**

.. math::
   f(n) = n, g(n) = n^2, h(n) = n^3, k(n) = n^4 \Rightarrow f(n) = O(g(n)) \text{ and } h(n) = O(k(n)) \Rightarrow f(n) * h(n) = O(g(n) * k(n)) = O(n^6).

Composition Rule
^^^^^^^^^^^^^^^^

If :math:`f(n) = O(g(n))` and :math:`g(n) = O(h(n))`, then :math:`f(g(n)) = O(h(n))`.

**Example:**

.. math::
   f(n) = n^2, g(n) = n, h(n) = n^3 \Rightarrow f(n) = O(g(n)) \text{ and } g(n) = O(h(n)) \Rightarrow f(g(n)) = O(h(n)) = O(n^3).